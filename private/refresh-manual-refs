#!/usr/bin/perl

# Copyright © 2001 Colin Watson
# Copyright © 2008 Jordà Polo
# Copyright © 2017-2019 Chris Lamb <lamby@debian.org>
# Copyright © 2021 Felix Lechner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

# You need copies of all the relevant manuals installed in the standard
# places locally (packages debian-policy, developers-reference, doc-base,
# python, lintian, menu, java-policy and vim-doc).

use v5.20;
use warnings;
use utf8;

use Const::Fast;
use Cwd qw(realpath);
use File::Basename qw(dirname);

# neither Path::This nor lib::relative are in Debian
use constant THISFILE => realpath __FILE__;
use constant THISDIR => dirname realpath __FILE__;

# use Lintian modules that belong to this program
use lib THISDIR . '/../lib';

use HTML::TokeParser::Simple;
use Path::Tiny;
use Unicode::UTF8 qw(decode_utf8 encode_utf8);
use WWW::Mechanize ();

const my $EMPTY => q{};
const my $UNDERSCORE => q{_};
const my $ASTERISK => q{*};
const my $DOLLAR => q{$};
const my $COLON => q{:};
const my $SLASH => q{/};

const my $DOUBLE_COLON => $COLON . $COLON;

my $dbk_index_re
  = qr/([\d.]+?)\.\s+<a\s*href="(.+?)"\s*>([\w\s[:punct:]]+?)<\/a\s*>/i;

my $folder = 'data/authority';
path($folder)->mkpath
  unless -e $folder;

refresh('policy', 'https://www.debian.org/doc/debian-policy/');

refresh('menu-policy',
    'https://www.debian.org/doc/packaging-manuals/menu-policy/');

refresh('perl-policy',
    'https://www.debian.org/doc/packaging-manuals/perl-policy/');

refresh('python-policy',
    'https://www.debian.org/doc/packaging-manuals/python-policy/');

refresh('java-policy',
    'https://www.debian.org/doc/packaging-manuals/java-policy/');

# presently not published online
refresh('lintian', 'file:///usr/share/doc/lintian/', 'lintian.html');

refresh('devref', 'https://www.debian.org/doc/developers-reference/');

refresh('menu', 'https://www.debian.org/doc/packaging-manuals/menu.html/');

# shipped as part of the doc-base installable
refresh('doc-base', 'file:///usr/share/doc/doc-base/doc-base.html/',
    'index.html');

# single page
refresh(
    'debconf-spec',
    'https://www.debian.org/doc/packaging-manuals/',
    'debconf_specification.html'
);

# single page version
# plain directory shows a file list
refresh('fhs', 'https://refspecs.linuxfoundation.org/FHS_3.0/','fhs-3.0.html');

# shipped as part of the vim installable
refresh_vim('vim-policy', 'file:///usr/share/doc/vim/vim-policy.html/',
    'index.html');

exit;

sub refresh {
    my ($manual, $base_url, $index_name) = @_;

    say "Working on manual '$manual'.";

    my $generated;
    open(my $memory_fd, '>', \$generated)
      or die encode_utf8('Cannot open scalar');

    extract_sections_from_links($memory_fd, $manual, $base_url, $index_name);

    close $memory_fd;

    write_data_file($generated, "$folder/$manual");

    return;
}

sub refresh_vim {
    my ($manual, $base_url, $index_name) = @_;

    say "Working on manual '$manual'.";

    my $generated;
    open(my $memory_fd, '>', \$generated)
      or die encode_utf8('Cannot open scalar');

    extract_vim($memory_fd, $manual, $base_url, $index_name);

    close $memory_fd;

    write_data_file($generated, "$folder/$manual");

    return;
}

sub write_data_file {
    my ($generated, $path) = @_;

    my $header =<<"HEADER";
# Data about titles, sections, and URLs of manuals, used to expand references
# in tag descriptions and add links for HTML output.  Each line of this file
# has three fields separated by double colons:
#
#     <section> :: <title> :: <url>
#
# If <section> is an underscore, that line specifies the title and URL for the
# whole manual.

HEADER

    say "Writing $path.";
    my $output = encode_utf8($header) . $generated;
    path($path)->spew($output);

    return;
}

sub extract_sections_from_links {
    my ($data_fd, $manual, $base_url, $page_name)= @_;

    $page_name //= $EMPTY;

    my $page_url = $base_url . $page_name;

    my $mechanize = WWW::Mechanize->new();
    $mechanize->get($page_url);

    my $page_title = $mechanize->title;

    # strip explanatory remark
    $page_title =~ s{ \s* \N{EM DASH} .* $}{}x;

    # underscore is a token for the whole page
    write_line($data_fd, $UNDERSCORE, $page_title, $page_url);

    my %by_section_key;
    my $in_appendix = 0;

    # https://stackoverflow.com/a/254687
    for my $link ($mechanize->links) {

        next
          unless length $link->text;

        my $regex = qr{^ \s* ([.\d]+) \s+ (.+) $}x;

        $regex = qr{^ \s* ([A-Z]|[A-Z]?[.\d]+) \s+ (.+) $}x
          if $manual eq 'perl-policy';

        next
          if $link->text !~ $regex;

        my $section_key = $1;
        my $section_title = $2;

        # drop final dots
        $section_key =~ s{ [.]+ $}{}x;

        # reduce consecutive whitespace
        $section_title =~ s{ \s+ }{ }gx;

        my $relative_destination = $link->url;

        my $destination_base = $page_url;
        $destination_base = dirname($page_url) . $SLASH
          unless $destination_base =~ m{ / $}x
          || $relative_destination =~ m{^ [#] }x;

        my $full_destination = $destination_base . $relative_destination;

        # developers reference likes to return locale specific pages
        $full_destination =~ s{ [.]\w{2}[.]html }{.html}x
          if $manual eq 'devref';

        next
          if exists $by_section_key{$section_key}
          && ( $by_section_key{$section_key}{title} eq $section_title
            || $by_section_key{$section_key}{destination} eq$full_destination);

        # Some manuals reuse section numbers for different references,
        # e.g. the Debian Policy's normal and appendix sections are
        # numbers that clash with each other. Track if we've already
        # seen a section pointing to some other URL than the current one,
        # and prepend it with an indicator
        $in_appendix = 1
          if exists $by_section_key{$section_key}
          && $by_section_key{$section_key}{destination} ne$full_destination;

        $section_key = "appendix-$section_key"
          if $in_appendix;

        # do not collect the upgrading checklists in appendix 10 of policy
        # the numbering changes all the time
        next
          if $manual eq 'policy'
          && $section_key =~ m{^ appendix-10 [.] }x;

        $by_section_key{$section_key}{title} = $section_title;
        $by_section_key{$section_key}{destination} = $full_destination;

        write_line($data_fd, $section_key, $section_title, $full_destination);
    }

    return;
}

sub extract_vim {
    my ($data_fd, $manual, $base_url, $page_name)= @_;

    $page_name //= $EMPTY;

    my $page_url = $base_url . $page_name;

    my $parser = HTML::TokeParser::Simple->new(url => $page_url);
    my $in_title = 0;
    my $in_dt_tag = 0;
    my $after_a_tag = 0;

    my $page_title = $EMPTY;
    my $section_key = $EMPTY;
    my $section_title = $EMPTY;
    my $relative_destination = $EMPTY;

    while (my $token = $parser->get_token) {

        if (length $token->get_tag) {

            if ($token->get_tag eq 'h1') {

                $in_title = ($token->is_start_tag
                      && $token->get_attr('class') eq 'title');

                # not yet leaving title
                next
                  if $in_title;

                # trim both ends
                $page_title =~ s/^\s+|\s+$//g;

                # underscore is a token for the whole page
                write_line($data_fd, $UNDERSCORE, $page_title, $page_url)
                  if length $page_title;

                $page_title = $EMPTY;
            }

            if ($token->get_tag eq 'dt') {

                $in_dt_tag = $token->is_start_tag;

                # not yet leaving dt tag
                next
                  if $in_dt_tag;

                # trim both ends
                $section_key =~ s/^\s+|\s+$//g;
                $section_title =~ s/^\s+|\s+$//g;

                my $full_destination = $base_url . $relative_destination;

                write_line($data_fd, $section_key, $section_title,
                    $full_destination)
                  if length $section_title;

                $section_key = $EMPTY;
                $section_title = $EMPTY;
                $relative_destination = $EMPTY;
            }

            if ($token->get_tag eq 'a') {

                $after_a_tag = $token->is_start_tag;

                $relative_destination = $token->get_attr('href')
                  if $token->is_start_tag;
            }

        } else {

            # concatenate span objects
            $page_title .= $token->as_is
              if length $token->as_is
              && $in_title
              && $after_a_tag;

            $section_key = $token->as_is
              if length $token->as_is
              && $in_dt_tag
              && !$after_a_tag;

            # concatenate span objects
            $section_title .= $token->as_is
              if length $token->as_is
              && $in_dt_tag
              && $after_a_tag;
        }
    }

    return;
}

sub write_line {
    my ($data_fd, $section_key, $section_title, $destination) = @_;

    # drop final dots
    $section_key =~ s{ [.]+ $}{}x;

    # reduce consecutive whitespace
    $section_title =~ s{ \s+ }{ }gx;

    my $line= join($DOUBLE_COLON,$section_key, $section_title, $destination);

    say {$data_fd} encode_utf8($line);

    return;
}

# Local Variables:
# indent-tabs-mode: nil
# cperl-indent-level: 4
# End:
# vim: syntax=perl sw=4 sts=4 sr et
