#!/usr/bin/perl

# Copyright © 2001 Colin Watson
# Copyright © 2008 Jordà Polo
# Copyright © 2017-2019 Chris Lamb <lamby@debian.org>
# Copyright © 2021 Felix Lechner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

# You need copies of all the relevant manuals installed in the standard
# places locally (packages debian-policy, developers-reference, doc-base,
# python, lintian, menu, java-policy and vim-doc).

use v5.20;
use warnings;
use utf8;

use Const::Fast;
use Cwd qw(realpath);
use File::Basename qw(dirname);
use HTTP::Tiny;
use Path::Tiny;
use Unicode::UTF8 qw(decode_utf8 encode_utf8);

# neither Path::This nor lib::relative are in Debian
use constant THISFILE => realpath __FILE__;
use constant THISDIR => dirname realpath __FILE__;

# use Lintian modules that belong to this program
use lib THISDIR . '/../lib';

use List::SomeUtils qw(none);

const my $EMPTY => q{};
const my $UNDERSCORE => q{_};
const my $ASTERISK => q{*};
const my $DOLLAR => q{$};
const my $COLON => q{:};
const my $SLASH => q{/};

const my $DOUBLE_COLON => $COLON . $COLON;

# field order
const my $PAGE_FIELDS => 1;
const my $DOCBOOK_FIELDS => 2;
const my $FHS_FIELDS => 3;

# For each manual, we need:
#  * Location of the manual index on the local filesystem
#  * Base URL for the eventual target of the reference (or empty string if no
#    public URL is available)
#  * Regex to match the possible references
#  * Mapping from regex fields to reference fields (array of arrays of
#    keywords: url, section title; the position of each keyword in the array
#    defines which is its corresponding group in the regex)
#
# Optionally, if there are subsections that aren't available in the index, an
# additional regex can be defined to match possible references on other pages
# of the manual.

my $title_re = qr/<title\s?>(.+?)(?:\s+&#8212.+|\s+v[\d.]+)?<\/title\s?>/i;
my $index_re
  = qr/<a href="(.+?)">\s*([A-Z]|[A-Z]?[\d\.]+?)\.?\s+([\w\s[:punct:]]+?)\s*<\/a>/;
my $sphinx_re
  = qr/<a class="reference internal" href="([^"]+)"(?: id="[^"]+")?>(\d[\d\.]*)(?:\s|&nbsp;)+(.*)<\/a>/;
my $dbk_index_re
  = qr/([\d.]+?)\.\s+<a\s*href="(.+?)"\s*>([\w\s[:punct:]]+?)<\/a\s*>/i;
my $dbk_index_re2
  = qr/<a\s*href="(.+?)"\s*>([\d.]+?)\.\s+([\w\s[:punct:]]+?)<\/a\s*>/i;

my $folder = 'data/authority';
path($folder)->mkpath
  unless -e $folder;

refresh(
    'policy',
    {
        base_url => 'https://www.debian.org/doc/debian-policy/',
        field_regex => $sphinx_re,
        field_order => $PAGE_FIELDS
    });

refresh(
    'menu-policy',
    {
        base_url =>'https://www.debian.org/doc/packaging-manuals/menu-policy/',
        field_regex => $index_re,
        field_order => $PAGE_FIELDS
    });

refresh(
    'perl-policy',
    {
        base_url =>'https://www.debian.org/doc/packaging-manuals/perl-policy/',
        field_regex => $index_re,
        field_order => $PAGE_FIELDS
    });

refresh(
    'python-policy',
    {
        base_url =>
          'https://www.debian.org/doc/packaging-manuals/python-policy/',
        field_regex => $sphinx_re,
        field_order => $PAGE_FIELDS
    });

refresh(
    'java-policy',
    {
        base_url =>'https://www.debian.org/doc/packaging-manuals/java-policy/',
        field_regex => $dbk_index_re2,
        field_order => $PAGE_FIELDS
    });

# shipped as part of the vim installable
refresh(
    'vim-policy',
    {
        local_path => '/usr/share/doc/vim/vim-policy.html/',
        index_name => 'index.html',
        field_regex => $dbk_index_re,
        field_order => $DOCBOOK_FIELDS
    });

# presently not published online
refresh(
    'lintian',
    {
        local_path => '/usr/share/doc/lintian/',
        index_name => 'lintian.html',
        field_regex => $sphinx_re,
        field_order => $PAGE_FIELDS
    });

refresh(
    'devref',
    {
        base_url => 'https://www.debian.org/doc/developers-reference/',
        field_regex => $sphinx_re,
        field_order => $PAGE_FIELDS,
        sub_regex =>
qr{<h[45] class="title"><a id="(.+?)"></a>([\d\.]+?)\.? ([\w\s[:punct:]]+?)</h[45]>},
    });

refresh(
    'menu',
    {
        base_url => 'https://www.debian.org/doc/packaging-manuals/menu.html/',
        field_regex => $index_re,
        field_order => $PAGE_FIELDS
    });

# shipped as part of the doc-base installable
refresh(
    'doc-base',
    {
        local_path => '/usr/share/doc/doc-base/doc-base.html/',
        index_name => 'index.html',
        field_regex => $index_re,
        field_order => $PAGE_FIELDS
    });

# single page
refresh(
    'debconf-spec',
    {
        base_url =>'https://www.debian.org/doc/packaging-manuals/',
        index_name => 'debconf_specification.html',
        field_regex => $index_re,
        field_order => $PAGE_FIELDS
    });

# single page version
# plain directory shows a file list
refresh(
    'fhs',
    {
        base_url =>'https://refspecs.linuxfoundation.org/FHS_3.0/',
        index_name => 'fhs-3.0.html',
        field_regex =>qr/<a\s+href="(.+?)"\s*>(\d[.\d]*)\s+([^<]+)<\/a\s*>/i,
        field_order => $PAGE_FIELDS
    });

exit;

sub refresh {
    my ($manual, $manual_data) = @_;

    my $local_path = $manual_data->{local_path};
    my $index_name = $manual_data->{index_name};
    my $field_regex = $manual_data->{field_regex};
    my $sub_regex = $manual_data->{sub_regex};

    if (length $local_path) {

        my $file_path = $local_path;
        $file_path .= $index_name
          if length $index_name;

        if (!-e $file_path) {
            say encode_utf8(
                "Manual '$manual' not available (missing: $local_path)\n");
            return;
        }
    }

    say "Working on manual '$manual'.";

    my $generated;
    open(my $memory_fd, '>', \$generated)
      or die encode_utf8('Cannot open scalar');

    # Extract references from the index.
    my @sub_pages
      = extract_refs($memory_fd, $manual, $manual_data, 0, $index_name,
        $field_regex);

    # Extract additional subsection references if not available in the index.
    for my $page_name (@sub_pages) {

        extract_refs($memory_fd, $manual, $manual_data, 1, $page_name,
            $sub_regex)
          if defined $sub_regex;
    }

    close $memory_fd;

    write_data_file($generated, "$folder/$manual");

    return;
}

sub write_data_file {
    my ($generated, $path) = @_;

    my $header =<<"HEADER";
# Data about titles, sections, and URLs of manuals, used to expand references
# in tag descriptions and add links for HTML output.  Each line of this file
# has three fields separated by double colons:
#
#     <section> :: <title> :: <url>
#
# If <section> is an underscore, that line specifies the title and URL for the
# whole manual.

HEADER

    say "Writing $path.";
    my $output = encode_utf8($header) . $generated;
    path($path)->spew($output);

    return;
}

# extract_refs -- Extract manual references from HTML file.
#
# This function takes the output file handle, the path to the page, and the
# regex to match, and prints references to stdout. The second argument is used
# to decide whether to look for the title (0) or not (1). It returns a list of
# pages linked by the extracted references.
sub extract_refs {
    my ($data_fd, $manual, $manual_data, $collected_index_page, $page_name,
        $field_regex)
      = @_;

    $page_name //= $EMPTY;

    my $local_path = $manual_data->{local_path};
    my $base_url = $manual_data->{base_url};
    my $index_name = $manual_data->{index_name};
    my $field_order = $manual_data->{field_order};

    my $page_url;
    my $page_contents;

    if (length $local_path) {

        $page_url = $local_path . $page_name;
        $page_contents = path($page_url)->slurp_utf8;

        $page_url = 'file://' . $page_url;

    } else {
        $page_url = $base_url . $page_name;

        my $response = HTTP::Tiny->new->get($page_url);
        unless ($response->{success}) {
            say encode_utf8("Failed to get $page_url!");
            return;
        }

        $page_contents = decode_utf8($response->{content});
    }

    # Read until there are 2 newlines. This hack is needed since some lines in
    # the Developer's Reference are cut in the middle of <a>...</a>.
    my @chunks = split(m{\n\n}, $page_contents);

    my %full_destination_by_section_key;
    my $in_appendix = 0;

    my @linked_pages = ();
    while (defined(my $chunk = shift @chunks)) {

        if (!$collected_index_page && $chunk =~ /$title_re/) {

            $collected_index_page = 1;

            # underscore is a token for the whole page
            my $line = join($DOUBLE_COLON, $UNDERSCORE, $1, $page_url);

            say {$data_fd} encode_utf8($line);
        }

        while ($chunk =~ /$field_regex/g) {

            my $relative_destination;
            my $section_title;
            my $section_key;

            if ($field_order == $PAGE_FIELDS) {
                $relative_destination = $1;
                $section_key = $2;
                $section_title = $3;
            }

            if ($field_order == $DOCBOOK_FIELDS) {
                $relative_destination = $2;
                $section_key = $1;
                $section_title = $3;
            }

            if ($relative_destination =~ m{^ ( .+? [.]html) }ix) {

                my $no_anchor = $1;

                push(@linked_pages, $no_anchor)
                  if none { m{\Q$no_anchor\E} } @linked_pages;
            }

      # If the extracted URL part doesn't look like a URL, assume it is
      # an anchor and convert to URL accordingly.
      #$relative_destination = basename($page_url) . "#$relative_destination"
      #  if $relative_destination && $relative_destination !~ /(?:#|\.html$)/i;

            my $destination_base = $page_url;
            $destination_base = dirname($page_url) . $SLASH
              unless $destination_base =~ m{ / $}x
              || $relative_destination =~ m{^ [#] }x;

            my $full_destination = $destination_base . $relative_destination;

            # developers reference likes to return locale specific pages
            $full_destination =~ s{ [.]\w{2}[.]html }{.html}x
              if $manual eq 'devref';

            # drop final dots
            $section_key =~ s{ [.]+ $}{}x;

            $section_key =~ s{^ [#](.+) $}{L$1}x;
            # Some manuals reuse section numbers for different references,
            # e.g. the Debian Policy's normal and appendix sections are
            # numbers that clash with each other. Track if we've already
            # seen a section pointing to some other URL than the current one,
            # and prepend it with an indicator
            $in_appendix = 1
              if exists $full_destination_by_section_key{$section_key}
              && $full_destination_by_section_key{$section_key} ne
              $full_destination;

            $section_key = "appendix-$section_key"
              if $in_appendix;

            # do not collect the upgrading checklists in appendix 10 of policy
            # the numbering changes all the time
            next
              if $manual eq 'policy'
              && $section_key =~ m{^ appendix-10 [.] }x;

            $full_destination_by_section_key{$section_key} = $full_destination;

            $section_title =~ s{ \s+ }{ }gx;
            $section_title =~ s{ <span[^>]*> (.*?) </span \s* > }{$1}igx;
            $section_title
              =~ s{ <code[^>]*> (.*?) </code \s* > }{<code>$1</code>}igx;

            my $line= join($DOUBLE_COLON,
                $section_key, $section_title, $full_destination);

            say {$data_fd} encode_utf8($line);
        }
    }

    return @linked_pages;
}

# Local Variables:
# indent-tabs-mode: nil
# cperl-indent-level: 4
# End:
# vim: syntax=perl sw=4 sts=4 sr et
