#!/usr/bin/perl

# Copyright © 2012 Niels Thykier <niels@thykier.net>
#  - Based on a shell script by Raphael Geissert <atomo64@gmail.com>
# Copyright © 2021 Felix Lechner
#
# This file is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This file is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.

use v5.20;
use warnings;
use utf8;

use Const::Fast;
use Cwd qw(realpath);
use File::Basename qw(dirname);
use List::Compare;
use List::SomeUtils qw(uniq);
use Unicode::UTF8 qw(encode_utf8);

# neither Path::This nor lib::relative are in Debian
use constant THISFILE => realpath __FILE__;
use constant THISDIR => dirname realpath __FILE__;

# use Lintian modules that belong to this program
use lib THISDIR . '/../lib';

use Path::Tiny;
use POSIX qw (strftime);
use Unicode::UTF8 qw(decode_utf8);

use Lintian::Deb822::File qw(parse_string);
use Lintian::IPC::Run3 qw(safe_qx);

const my $EMPTY => q{};
const my $SPACE => q{ };
const my $BAR => q{|};
const my $DIVIDER => $SPACE . $BAR . $BAR . $SPACE;

my $data_path = shift;
die encode_utf8("Usage: $0 path/to/lintian/data\n")
  unless length $data_path;

$ENV{LC_ALL} = 'C';
delete $ENV{DEB_HOST_ARCH};

my $version_output = decode_utf8(safe_qx('dpkg-architecture', '--version'));
my ($dpkg_version) = split(/\n/, $version_output);
chomp $dpkg_version;

my @architectures
  = split(/\n/, decode_utf8(safe_qx('dpkg-architecture', '-L')));
chomp for @architectures;

say encode_utf8('Working on dpkg variables.');

my %variables;

for my $architecture (@architectures) {

    my @lines
      = split(/\n/,
        decode_utf8(safe_qx('dpkg-architecture', "-a$architecture")));

    for my $line (@lines) {
        my ($key, $value) = split(/=/, $line, 2);
        $variables{$architecture}{$key} = $value;
    }
}

{
    my $filename = 'common/multiarch-dirs';
    my $header =<<'EOT';
# List of "Multiarch dirs" relationships as provided by
# dpkg-architecture - arch -> dir mapping
EOT

    my @lines = map { $_ . $SPACE . $variables{$_}{DEB_HOST_MULTIARCH} }
      keys %variables;

    my $file_path = "$data_path/" . $filename;
    write_file($file_path, $header, $dpkg_version, @lines);
}

{
    my $filename = 'files/triplets';
    my $header =<<'EOT';
# List of "triplet architecture" relationships as provided by
# dpkg-architecture'
EOT

    my @lines = map { $variables{$_}{DEB_HOST_MULTIARCH} . $SPACE . $_ }
      keys %variables;

    my $file_path = "$data_path/" . $filename;
    write_file($file_path, $header, $dpkg_version, @lines);
}

{
    my $filename = 'common/architectures';
    my $header =<<'EOT';
# List of known architectures as provided by dpkg-architecture
# (excluding "all" and "any", which are handled specially)
EOT

    my @lines;
    for my $architecture (keys %variables) {

        my $line
          = $variables{$architecture}{DEB_HOST_ARCH}
          . $DIVIDER
          . $variables{$architecture}{DEB_HOST_ARCH_OS}
          . $SPACE
          . $variables{$architecture}{DEB_HOST_ARCH_CPU};
        push(@lines, $line);
    }

    my $file_path = "$data_path/" . $filename;
    write_file($file_path, $header, $dpkg_version, @lines);
}

{
    my $filename = 'shared-libs/ldconfig-dirs';
    my $header =<<'EOT';
# The list of directories searched by default by the dynamic linker.
# Packages installing shared libraries into these directories must call
# ldconfig, must have shlibs files, and must ensure those libraries have
# proper SONAMEs.
#
# Directories listed here must not have leading slashes.
#
# On the topic of multi-arch dirs.  Hopefully including the ones not
# native to the local platform won't hurt.
#
# See Bug#469301 and Bug#464796 for more details.
#
EOT

    my @multiarch = map { $variables{$_}{DEB_HOST_MULTIARCH} } keys %variables;
    my @lines = map { ("lib/$_", "usr/lib/$_") } @multiarch;

    my @always = qw{
      lib
      lib32
      lib64
      libx32
      usr/lib
      usr/lib32
      usr/lib64
      usr/libx32
      usr/local/lib
    };
    push(@lines, @always);

    my $file_path = "$data_path/" . $filename;
    write_file($file_path, $header, $dpkg_version, @lines);
}

say encode_utf8('Working on hardening flags.');

my @known_features = qw{
  fortify
  relro
  stackprotector
  bindnow
  pie
};

my %hardening_tags;
for my $architecture (@architectures) {

    # find all recommended hardening features
    local $ENV{DEB_HOST_ARCH} = $architecture;
    local $ENV{DEB_BUILD_MAINT_OPTIONS} = 'hardening=+all';

    my @recommended_features = get_hardening_flags();

    my $lc = List::Compare->new(\@known_features, \@recommended_features);
    my @important_features = $lc->get_intersection;

    my @tag_names = sort map { 'hardening-no-' . $_ } @important_features;

    my %renames = ('hardening-no-fortify' => 'hardening-no-fortify-functions');
    my @renamed_tags = map { $renames{$_} // $_ } @tag_names;

    $hardening_tags{$architecture} = join(', ', @renamed_tags);
}

{
    my $filename = 'binaries/hardening-tags';
    my $header =<<'EOT';
# Map of architectures to enabled hardening tags.
#
# NB: Keep this in sync with checks/binaries.desc
EOT

    my @lines
      = map { $_ . $DIVIDER . $hardening_tags{$_} } keys %hardening_tags;

    my $file_path = "$data_path/" . $filename;
    write_file($file_path, $header, $dpkg_version, @lines);
}

exit 0;

sub get_hardening_flags {

    my @command = qw{dpkg-buildflags --query-features hardening};

    my $feature_output = decode_utf8(safe_qx(@command));

    my $deb822 = Lintian::Deb822::File->new;
    my @sections = $deb822->parse_string($feature_output);

    my @enabled = grep { $_->value('Enabled') eq 'yes' } @sections;
    my @features = map { $_->value('Feature') } @enabled;

    return uniq @features;
}

sub write_file {
    my ($file_path, $header, $tool_version, @lines) = @_;

    open(my $fd, '>', $file_path)
      or die "Cannot open $file_path for writing";

    print {$fd} encode_utf8($header)
      if length $header;

    my $date = strftime('%Y-%m-%d', gmtime);

    my $stamp =<<"EOT";
# Last updated: $date
# With: $tool_version
# This file was auto-generated by $0
EOT

    print {$fd} encode_utf8($stamp);

    say {$fd} encode_utf8($EMPTY);

    say {$fd} encode_utf8($_) for sort @lines;

    close $fd;

    return;
}

# Local Variables:
# indent-tabs-mode: nil
# cperl-indent-level: 4
# End:
# vim: syntax=perl sw=4 sts=4 sr et
