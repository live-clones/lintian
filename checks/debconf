#!/usr/bin/perl -w
# debconf -- lintian check script

# Copyright (C) 2001 Colin Watson
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
# MA 02111-1307, USA.

use strict;

use lib "$ENV{'LINTIAN_ROOT'}/lib";
use Dep;
use Util;

($#ARGV == 1) or fail("syntax: debconf <pkg> <type>");
my $pkg = shift;
my $type = shift;

# From debconf-devel(7), section 'THE TEMPLATES FILE', uptodate with debconf
# version 1.3.22
my %template_fields;
map { $template_fields{$_}=1 } qw(template type choices default description);

# From debconf-devel(7), section 'THE TEMPLATES FILE', uptodate with debconf
# version 1.3.22
my %valid_types;
map { $valid_types{$_}=1 } qw(
	string
	password
	boolean
	select
	multiselect
	note
	text
	title
	);
$valid_types{error} = 1 if $type eq 'udeb';

my $seenconfig='';
my $seentemplates='';
my $usespreinst='';
my $usesmultiselect='';

if (-f "control/config") {
    $seenconfig=1;
}
if (-f "control/templates") {
    $seentemplates=1;
}

exit unless $seenconfig or $seentemplates;

# Check that both debconf control area files are present.
if ($seenconfig and not $seentemplates) {
    print "W: $pkg $type: no-debconf-templates\n";
} elsif ($seentemplates and not $seenconfig and $type ne 'udeb') {
    print "W: $pkg $type: no-debconf-config\n";
}

if ($seenconfig and not -x "control/config") {
    print "E: $pkg $type: debconf-config-not-executable\n";
}

# First check that templates look valid
if ($seentemplates) {
    open(TMPL, "control/templates") or fail("Can't open control/templates: $!");
    local $/ = "\n\n";
    while (<TMPL>) {
	chomp;
	my %fields = ();
	my $name = 'unknown';

	foreach my $line (split "\n", $_) {
	    if ($line =~ s/^([-_.A-Za-z0-9]+):\s*(.+)//) {
		$fields{$1}++;
		$name = $2 if ($1 eq 'Template');
	    }
	}

	foreach (keys %fields) {
	    if ($fields{$_} > 1) {
		print "E: $pkg $type: duplicate-fields-in-templates $name $_\n";
		#  Templates file is corrupted, no need to report
		#  further errors
		$seentemplates = '';
	    }
	}
    }
    close TMPL;
}

# Lots of template checks.

my @templates = $seentemplates ? read_dpkg_control("control/templates", "templates file") : ();

foreach my $template (@templates) {
    my $isselect='';

    if (not exists $template->{template}) {
	print "E: $pkg $type: no-template-name\n";
	$template->{template} = 'no-template-name';
    } elsif ($template->{template}!~m|[A-Za-z0-9.+-](?:/[A-Za-z0-9.+-])|) {
	print "E: $pkg $type: malformed-template-name $template->{template}\n";
    }

    if (not exists $template->{type}) {
	print "E: $pkg $type: no-template-type $template->{template}\n";
    } elsif (not $valid_types{$template->{type}}) {
	print "E: $pkg $type: unknown-template-type $template->{type}\n";
    } elsif ($template->{type} eq 'select') {
	$isselect=1;
    } elsif ($template->{type} eq 'multiselect') {
	$isselect=1;
	$usesmultiselect=1;
    } elsif ($template->{type} eq 'boolean') {
	print "E: $pkg $type: boolean-template-has-bogus-default ".
	    "$template->{template} $template->{default}\n"
		if defined $template->{default}
		    and $template->{default} ne 'true'
		    and $template->{default} ne 'false';
    }

    for my $key (keys %$template) {
	if (($key =~ /^choices-/) and
	    ($template->{choices} && $template->{choices} !~ /^\s*$/) and 
	    (! $template->{$key} || $template->{$key} =~ /^\s*$/)) {
	    print "E: $pkg $type: empty-translated-choices $key\n";
	}
    }

    if ($isselect and not exists $template->{choices}) {
	print "E: $pkg $type: select-without-choices $template->{template}\n";
    }

    if (not exists $template->{description}) {
	print "E: $pkg $type: no-template-description $template->{template}\n";
    } elsif ($template->{description}=~m/^\s*(.*?)\s*?\n\s*\1\s*$/) {
	# Check for duplication. Should all this be folded into the
	# description checks?
	print "W: $pkg $type: duplicate-long-description-in-template ",
	      "$template->{template}\n";
    }

    my %languages;
    foreach my $field (sort keys %$template) {
	# Tests on translations
	my ($mainfield, $lang) = split m/-/, $field, 2;
	if (defined $lang) {
	    if ($isselect and $mainfield eq 'default') {
	        print "W: $pkg $type: select-with-translated-default-field ",
	              "$template->{template} $lang\n";
	    }
	    $languages{$lang}{$mainfield}=1;
	}
	unless ($template_fields{$mainfield}) { # Ignore language codes here
	    print "E: $pkg $type: unknown-field-in-templates $field\n";
	}
    }
    if (exists $template->{choices}
	&& $template->{choices} !~ m/^\s*\$\{\w+\}\s*$/) {
	foreach my $lang (sort keys %languages) {
	    if ($languages{$lang}{choices} xor $languages{$lang}{description}) {
		print "W: $pkg $type: partially-translated-question $template->{template} $lang\n";
	    }
	}
    }
}

# parse depends info for later checks

# Consider every package to depend on itself.
my $version;
if (-f "fields/version") {
    open(IN, "fields/version") or fail("Can't open fields/version: $!");
    chomp($_ = <IN>);
    $version = "$pkg (= $_)";
    close IN;
}

my (%dependencies, @alldeps);

for my $field (qw(depends pre-depends)) {
    if (-f "fields/$field") {
	open(IN, "fields/$field") or fail("Can't open fields/$field: $!");
	chomp($_ = <IN>);
	$_ .= ", $version" if defined $version;
	$_ =~ s/debconf-2\.0/debconf (>= 1.2.30)/go;
	$_ =~ s/cdebconf(-\w+)?(-udeb)?\s*(\(.+?\))?/debconf (>= 1.2.30)/g;
	$_ =~ s/libdebconfclient.?(-udeb)?\s*(\(.+?\))?/debconf (>= 1.2.30)/g;
        push @alldeps, $_;
	$dependencies{$field} = Dep::parse($_);
    } else {
	my $dep = $version;
	$dep =~ s/debconf-2\.0/debconf (>= 1.2.30)/go;
	$dep =~ s/cdebconf(-\w+)?(-udeb)?\s*(\(.+?\))?/debconf (>= 1.2.30)/g;
	$dep =~ s/libdebconfclient.?(-udeb)?\s*(\(.+?\))?/debconf (>= 1.2.30)/g;
	push @alldeps, $dep;
	$dependencies{$field} = Dep::parse($dep);
    }
}

my $alldependencies = Dep::parse(join ', ', @alldeps);

# Check the maintainer scripts.

if (open(PREINST, "control/preinst")) {
    while (<PREINST>) {
	s/#.*//;    # Not perfect for Perl, but should be OK
	if (m,/usr/share/debconf/confmodule, or
	        m/(?:Debconf|Debian::DebConf)::Client::ConfModule/) {
	    $usespreinst=1;
	    last;
	}
    }
    close PREINST;
}

for my $file (qw(config postinst)) {
    if (open(IN, "control/$file")) {
	my $usesconfmodule='';
	my $obsoleteconfmodule='';
	my $db_input='';
	my $isdefault='';
	my $usesseen='';

	my $fl = <IN>;
	next if $fl !~ /^#!/; # skip, if not a script

	while (<IN>) {
	    s/#.*//;    # Not perfect for Perl, but should be OK
	    next unless m/\S/;
	    if (m#(?:\.|source)\s+/usr/share/debconf/confmodule# ||
	            m/use\s+Debconf::Client::ConfModule/) {
	        $usesconfmodule=1;
	    }
	    if (not $obsoleteconfmodule and
	        m#(/usr/share/debconf/confmodule\.sh|
	           Debian::DebConf::Client::ConfModule)#x) {
	        print "W: $pkg $type: $file-loads-obsolete-confmodule $1\n";
	        $usesconfmodule=1;
	        $obsoleteconfmodule=1;
	    }
	    if ($file eq 'postinst' and not $db_input and m/db_input/) {
	        # TODO: Perl?
	        print "W: $pkg $type: postinst-uses-db-input\n"
		    unless $type eq 'udeb';
	        $db_input=1;
	    }
	    if (not $isdefault and m/db_fset.*isdefault/) {
	        # TODO: Perl?
	        print "W: $pkg $type: isdefault-flag-is-deprecated $file\n";
	        $isdefault=1;
	    }
	    if (not $usesseen and m/db_f[sg]et\s+\S+\s+seen\s+/) {
	       unless (Dep::implies($alldependencies,
	                 Dep::parse('debconf (>= 0.5)'))) {
	           print "E: $pkg $type: seen-flag-requires-versioned-depends $file\n" 
		       unless $type eq 'udeb';
	       }
	        $usesseen = 1;
	    }
	}

	unless ($usesconfmodule) {
	    print "W: $pkg $type: $file-does-not-load-confmodule\n" 
		unless $type eq 'udeb';
	}

	close IN;
    }
}

if (open(POSTRM, "control/postrm")) {
    my $db_purge='';

    while (<POSTRM>) {
	s/#.*//;    # Not perfect for Perl, but should be OK
	if (not $db_purge and m/db_purge/) {    # TODO: Perl?
	    $db_purge=1;
	}
    }

    unless ($db_purge) {
	print "W: $pkg $type: postrm-does-not-purge-debconf\n";
    }
}

# Check that the right dependencies are in the control file.

if ($usesmultiselect) {
    unless (Dep::implies($alldependencies,
	                 Dep::parse('debconf (>= 0.2.26)'))) {
	print "W: $pkg $type: multiselect-without-dependency\n"
	    unless $type eq 'udeb';
    }
} elsif ($usespreinst) {
    unless (Dep::implies($dependencies{'pre-depends'},
	                 Dep::parse('debconf (>= 0.2.17)'))
	    or Dep::implies($dependencies{'depends'}, Dep::parse('debconf'))) {
	print "W: $pkg $type: missing-debconf-dependency-for-preinst\n"
	    unless $type eq 'udeb';
    }
} else {
    unless (Dep::implies($alldependencies, Dep::parse('debconf'))) {
	print "W: $pkg $type: missing-debconf-dependency\n";
    }
}

# Now make sure that no scripts are using debconf as a registry.
# Unfortunately this requires us to unpack to level 2 and grep all the
# scripts in the package.
# the following checks is ignored if the package being checked is debconf
# itself.

exit 0 if ($pkg eq "debconf") || ($type eq 'udeb');

open(SCRIPTS, "scripts") or fail("cannot open lintian scripts file: $!");
while (<SCRIPTS>) {
    chomp;

    # From checks/scripts.
    my ($calls_env, $interpreter, $filename) = m/^(env )?(\S*) (.*)$/
	or fail("bad line in scripts file: $_");

    open(IN, "< unpacked/$filename") or fail("cannot open $filename: $!");
    while (<IN>) {
	s/#.*//;    # Not perfect for Perl, but should be OK
	if (m,/usr/share/debconf/confmodule, or
	        m/(?:Debconf|Debian::DebConf)::Client::ConfModule/) {
	    print "W: $pkg $type: debconf-is-not-a-registry $filename\n";
	    last;
	}
    }
    close IN;
}
close SCRIPTS;

exit 0;

